## 操作系统实验
HITSZ 2023秋 OS实验
### 实验一：Utilities（util）
借助系统调用实现几个简单的命令，主要目的还是熟悉一下xv6，较简单。由于是从xv6实验中摘了几个，我称为小xv6实验。
1. `sleep`：照抄PPT代码
1. `pingpong`：考察管道的使用和进程创建
1. `find`：考察文件相关系统调用的使用，由于接口和Linux不一样，费了点劲儿。但是有`ls.c`作为参考，倒是也还好。
### 实验二：System calls（syscall）
修改和实现几个系统调用，需要花点时间理清从用户空间调用系统接口的全过程。几乎是完全魔改了xv6实验，由于干涉了系统原来的正常运行，不太喜欢。
1. 魔改`exit()`：在进程退出时打印父进程信息和子进程信息，插入几条语句就好
1. 魔改`wait()`：添加一个参数用来指定阻塞与否
1. 实现`yield()`：要求比正常的`yield`多一个信息的打印语句。`proc.c`里原有一个`yield`，一开始直接在上边改的，结果影响到了`kernel`的函数，没能过测。后来旁路了它，实际上还是照抄原来的加了条打印语句。
### 实验三：Lock（lock）
修改原先的`kalloc.c`和`bio.c`优化内存和缓存管理的锁争用问题，比前两个实验难一些，感觉...倒是没怎么帮助理解锁的原理？
1. 优化`kalloc`：要求把统一的内存链表和锁拆分成每CPU一个，要求实现“窃取”功能倒是比较有趣。没遇到什么锁相关的问题。倒是`initlock()`没细看，以为会拷贝传入的字符串，所以传入的参数都放在了栈上，引起了奇怪的问题，研究了一会儿。
1. 优化`bcache`：要求把统一的缓存链表和锁拆分进多个哈希桶，基本上跟`kalloc`的优化没什么区别。但因为缓存分配后也是留在队列里的，“窃取”过程中写得不谨慎可能会同时持有两把锁，这样会有死锁问题。